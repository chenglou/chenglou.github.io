<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Story of Your Life</title>
  <style>
    canvas {
      position: absolute;
    }
  </style>
</head>
<body>
<script>
'use strict'

const life = Math.floor(75 * 365.25)
const today = new Date().getDay() // sunday = 0
const age = Math.floor((30 * 365.25 + 19) / 7) * 7 + today - 1 // rough days, rounded to week, 0-indexed

// === constant layout metrics. The rest is dynamic
const leftBlockRadius = [99, 0, 0, 99], rightBlockRadius = [0, 99, 99, 0], pillRadius = [99, 99, 99, 99]
const gridGap = 8

// === state
const customDot_ = localStorage.getItem('customDot')
let customDot = customDot_ == null ? null : parseInt(customDot_)
let inputs = {
  pointer: {x: -Infinity, y: -Infinity}, // btw, on page load, there's no way to render a first cursor state =(
  clicked: false,
}
let canvas = document.createElement('canvas')
let ctx = canvas.getContext('2d')
document.body.appendChild(canvas)

let cacheCanvas1 = document.createElement('canvas')
let cacheCtx1 = cacheCanvas1.getContext('2d')
let cacheCanvas2 = document.createElement('canvas')
let cacheCtx2 = cacheCanvas2.getContext('2d')

// === events
window.addEventListener('resize', () => render())
window.addEventListener('mousemove', (e) => {
  // when scrolling (which might schedule a render), a container's mousemove doesn't trigger, so the pointer's local coordinates are stale
  // this means we should only use pointer's global coordinates, which is always right (thus the subtraction of scroll)
  inputs.pointer.x = e.pageX -/*toGlobal*/window.scrollX; inputs.pointer.y = e.pageY -/*toGlobal*/window.scrollY
  // btw, pointer can exceed document bounds, e.g. dragging reports back out-of-bound, legal negative values
  render()
})
window.addEventListener('click', (e) => {
  inputs.clicked = true
  // needed to update coords even when we already track mousemove. E.g. in Chrome, right click context menu, move elsewhere, then click to dismiss. BAM, mousemove triggers with stale/wrong (??) coordinates... Click again without moving, and now you're clicking on the wrong thing
  inputs.pointer.x = e.pageX - window.scrollX; inputs.pointer.y = e.pageY - window.scrollY
  render()
})

// === hit testing logic. Boxes' hit area should be static and not follow their current animated state usually (but we can do either). Use the dynamic area here for once
function hitTest(blockSize, countX, countY, gridLeft, gridTop, gridFinalSizeX, gridFinalSizeY, pointer) {
  const px = pointer.x-/*toLocal*/gridLeft
  const py = pointer.y-/*toLocal*/gridTop
  if (px < 0 || px > gridFinalSizeX || py < 0 || py > gridFinalSizeY) return null
  return Math.floor(py / blockSize) * countX + Math.floor(px / blockSize)
}

function render() {
  // === step 1: batched DOM reads (to avoid accidental DOM read & write interleaving)
  const devicePixelRatio = window.devicePixelRatio
  const windowSizeX = document.documentElement.clientWidth
  const windowSizeY = window.innerHeight
  const gridSizeX = windowSizeX - gridGap
  const gridSizeY = windowSizeY - gridGap
  let {pointer} = inputs

  const blockSize_ = (life * Math.sqrt((4*life*gridSizeX*gridSizeY + (7*gridSizeY)**2) / (life**2)) + 7 * gridSizeY) / 2 / life
  const countX = Math.floor((gridSizeX / blockSize_) / 7) * 7
  const countY = Math.ceil(life / countX)
  const blockSize = gridSizeY / countY
  const gridFinalSizeX = countX * blockSize
  const gridFinalSizeY = countY * blockSize
  const gridLeft = (windowSizeX - gridFinalSizeX) / 2 // center
  const gridTop = (windowSizeY - gridFinalSizeY) / 2 // center

  // === step 2: handle inputs-related state change
  const hover = hitTest(blockSize, countX, countY, gridLeft, gridTop, gridFinalSizeX, gridFinalSizeY, pointer)
  const newCustomDot =
    inputs.clicked && hover === customDot ? null
    : inputs.clicked ? hover
    : customDot
  const cursor = hover == null ? 'auto' : 'pointer'

  // === step 5: render. Batch DOM writes
  // no blurry canvas: coderwall.com/p/vmkk6a/how-to-make-the-canvas-not-look-like-crap-on-retina
  canvas.width = gridFinalSizeX * devicePixelRatio // different than canvas.style.width. Btw this clears the canvas as well
  canvas.height = gridFinalSizeY * devicePixelRatio
  canvas.style.width = gridFinalSizeX
  canvas.style.height = gridFinalSizeY
  canvas.style.left = gridLeft
  canvas.style.top = gridTop
  ctx.scale(devicePixelRatio, devicePixelRatio)
  ctx.clearRect(0, 0, gridFinalSizeX, gridFinalSizeY)

  cacheCanvas1.width = blockSize * 7 * devicePixelRatio
  cacheCanvas1.height = blockSize * devicePixelRatio
  cacheCanvas1.style.width = blockSize * 7
  cacheCanvas1.style.height = blockSize
  cacheCtx1.scale(devicePixelRatio, devicePixelRatio)
  cacheCtx1.clearRect(0, 0, blockSize * 7, blockSize)
  //
  cacheCtx1.fillStyle = 'hsl(120, 73%, 75%)'
  cacheCtx1.beginPath()
  cacheCtx1.roundRect(0, 0, blockSize * 7, blockSize, pillRadius)
  cacheCtx1.fill()
  cacheCtx1.stroke()
  cacheCtx1.strokeStyle = 'hsl(120, 73%, 30%)'
  cacheCtx1.lineWidth = 0.5
  for (let i = 1; i < 7; i++) {
    cacheCtx1.moveTo(blockSize * i, 0)
    cacheCtx1.lineTo(blockSize * i, blockSize)
    cacheCtx1.stroke()
  }

  cacheCanvas2.width = blockSize * 7 * devicePixelRatio
  cacheCanvas2.height = blockSize * devicePixelRatio
  cacheCanvas2.style.width = blockSize * 7
  cacheCanvas2.style.height = blockSize
  cacheCtx2.scale(devicePixelRatio, devicePixelRatio)
  cacheCtx2.clearRect(0, 0, blockSize * 7, blockSize)
  //
  cacheCtx2.fillStyle = 'white'
  cacheCtx2.beginPath()
  cacheCtx2.roundRect(0, 0, blockSize * 7, blockSize, pillRadius)
  cacheCtx2.fill()
  cacheCtx2.stroke()
  cacheCtx2.strokeStyle = 'hsl(120, 73%, 30%)'
  cacheCtx2.lineWidth = 0.5
  for (let i = 1; i < 7; i++) {
    cacheCtx2.moveTo(blockSize * i, 0)
    cacheCtx2.lineTo(blockSize * i, blockSize)
    cacheCtx2.stroke()
  }

  ctx.strokeStyle = 'hsl(120, 73%, 30%)'
  ctx.lineWidth = 0.5

  for (let i = 0; i < life; i++) {
    const x = i % countX * blockSize
    const y = Math.floor(i / countX) * blockSize

    if (Math.floor(i / 7) < Math.floor(age / 7)) {
      ctx.drawImage(cacheCanvas1, x, y, blockSize * 7, blockSize);
      // ctx.fillStyle = 'hsl(120, 73%, 75%)'
      // ctx.beginPath()
      // ctx.roundRect(x, y, blockSize * 7, blockSize, pillRadius)
      // ctx.fill()
      // ctx.stroke()
      // // for (let j = 1; j < 7; j++) {
      // //   ctx.moveTo(x + blockSize * j, y)
      // //   ctx.lineTo(x + blockSize * j, y + blockSize)
      // //   ctx.stroke()
      // // }
      i += 6
      continue
    } else if (Math.floor(i / 7) > Math.floor(age / 7) + 1) {
      ctx.drawImage(cacheCanvas2, x, y, blockSize * 7, blockSize);
      i += 6
      continue
    }

    ctx.fillStyle =
      i === hover || i === newCustomDot ? 'orange'
      : i < age ? 'hsl(120, 73%, 75%)'
      : i === age ? 'hsl(120, 73%, 40%)'
      : i === life - 1 ? 'red'
      : 'white'

    const radius =
      i % 7 === 0 ? leftBlockRadius
      : i % 7 === 6 ? rightBlockRadius
      : 0
    ctx.beginPath()
    ctx.roundRect(x, y, blockSize, blockSize, radius)
    ctx.fill()
    ctx.stroke()
  }
  document.body.style.cursor = cursor

  // === step 6: update state & prepare for next frame
  inputs.clicked = false
  if (customDot !== newCustomDot) {
    localStorage.setItem('customDot', newCustomDot) // TODO: validate (e.g. out of range)
    customDot = newCustomDot
  }
}

render()
</script>
</body>
